;; I totaly suck a maths but i hear that project euler helps one gertting started
;; plus, a little maths wont hurt, i guess.

;; If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
;; The sum of these multiples is 23.
;; Find the sum of all the multiples of 3 or 5 below 1000.

;; helper function to generate a range, taken from SO
(defun make-range (end &key (start 0) (step 1))
  (loop for i from start below end by step collect i))

;; so at first i went with a copy of my errlang solution, using lists:foldl and lists:seq
;; unfortunately i was way over my head with this reduce function wich quite franckly, fucked up my brain.

;; (defun sum-it (x acc)
;;   (format t "x = ~D sum = ~D~%" x acc)
;;   (cond
;; 	((or (zerop (mod x 5)) (zerop (mod x 3)))
;; 	 ;(format t "x = ~D sum = ~D; x + sum = ~D~%" x sum (+ sum x))
;; 	 (+ acc x))
;; 	(t acc)))

;; (defun multiple-of-3-and-5 (limit)
;;   (format t "~{~D~%~}" (make-range limit))
;;   (reduce #'sum-it (make-range limit) :initial-value 0))

;; so juste went over http://www.unixuser.org/~euske/doc/cl/loop.html to see how i
;; could loop on numbers from 0 to n and found sum. hence the following
(defun sum-of-3-or-5 (max)
  (loop for i from 1 to max
	 if (or (zerop (mod i 3)) (zerop (mod i 5)))
	 sum i))

(defun problem1 ()
  (sum-of-3-or-5 999)) ; will produce 233168; great success

;; Each new term in the Fibonacci sequence is generated by adding the previous two terms.
;; By starting with 1 and 2, the first 10 terms will be:
;; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
;; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

;; helper function that produces the nth number in the fibonacci sequence
(defun fib (n)
  (cond
	((= 1 n) 1)
	((= 2 n) 2)
	(t (+ (fib (- n 1)) (fib (- n 2)))))) ; RPN FFS !! (+ 1 1) and not (1 + 1)

;; no major problem here
(defun sum-even-fib (a)
  (let ((x (fib a)))
	(cond
	  ((< x 4000000)
	   (cond
		 ((zerop (mod x 2))
		  (+ (fib a) (sum-even-fib (+ a 1))))
		 (t (sum-even-fib (+ a 1)))))
	  (t 0))))

(defun problem2 ()
  (sum-even-fib 1))
